<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>MAIN</title>
</head>
<body>
	<nav>
		<ul>
			<li><a href="#">main</a></li>
			<li><a href="#sub1">sub1</a></li>
			<li><a href="#sub2">sub2</a></li>
		</ul>
	</nav>
	<section>
		<h1>MAIN</h1>
		This is main page.
	</section>
<!-- 
 	<div class="one">one</div>
 	<div class="two">two</div>
 	<div class="three">three</div>
 	<div class="four">four</div>
 -->
	<script>
		//const test  = document.querySelector('body');
		//console.log(test.removeChild('one'));
		//console.log(test.childNodes);
// 		(function(){
// 			var sectionEl = document.querySelector('section');
// 			var mainHtml = sectionEl.innerHTML;
// 			var routerMap = {
// 				'' : function() {
// 					sectionEl.innerHTML = mainHtml;
// 				},
// 				'sub1' : function() {
// 					drawSection(board_url)
// 				},
// 				'sub2' : function() {
// 					drawSection(board_url)
// 				}
// 			}

// 			function otherwise() {
// 				sectionEl.innerHTML =
// 				'Not Found';
// 			}

// 			function router() {
// 				var hashValue = location.hash.replace('#', '');
// 				(routerMap[hashValue] || otherwise)();
// 			}


// 			function drawSection(url) {
// 				ajaxGet(url, function(response) {
// 					var data = JSON.parse(response);
// 					document.querySelector('section').innerHTML =
// 					'<h1>' + data.title +  '</h1>'
// 					+data.content
// 				});
// 			}


// 			function ajaxGet(url, callback) {
// 				url = url || ''; //인자가없는 경우 사용 
// 				callback = callback || function () { ; };
// 				var xhr = new XMLHttpRequest();
// 				xhr.open("get", url, true);
// 				xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
// 				var that = this;
// 				xhr.onload = function () {
// 					callback.apply(that, [xhr.response]);
// 				};
// 				xhr.send(null);
// 			}


// 출처: https://www.reimaginer.me/entry/spa-and-spa-routing [Reimaginer]

// window.addEventListener('DOMContentLoaded', router);
// window.addEventListener('hashchange', router);
// })();





(function () {
  const root = document.querySelector('.app-root');

  const routes = {
    // hash: url
    '': '/data/home.json',
    service: '/data/service.json',
    about: '/data/about.html'
  };

  const render = async () => {
    try {
      // url의 hash를 취득
      const hash = location.hash.replace('#', '');
      const url = routes[hash];
      if (!url) {
        root.innerHTML = `${hash} Not Found`;
        return;
      }

      const res = await fetch(url);
      const contentType = res.headers.get('content-type');

      if (contentType?.includes('application/json')) {
        const json = await res.json();
        root.innerHTML = `<h1>${json.title}</h1><p>${json.content}</p>`;
      } else {
        root.innerHTML = await res.text();
      }
    } catch (err) {
      console.error(err);
    }
  };

  // 네비게이션을 클릭하면 uri의 hash가 변경된다. 주소창의 uri가 변경되므로 history 관리가 가능하다.
  // 이때 uri의 hash만 변경되면 서버로 요청을 수행하지 않는다.
  // 따라서 uri의 hash가 변경하면 발생하는 이벤트인 hashchange 이벤트를 사용하여 hash의 변경을 감지하여 필요한 AJAX 요청을 수행한다.
  // hash 방식의 단점은 uri에 불필요한 #이 들어간다는 것이다.
  window.addEventListener('hashchange', render);

  // DOMContentLoaded은 HTML과 script가 로드된 시점에 발생하는 이벤트로 load 이벤트보다 먼저 발생한다. (IE 9 이상 지원)
  // 새로고침이 클릭되었을 때, 웹페이지가 처음 로딩되었을 때, 현 페이지(예를 들어 loclahost:5003/#service)를 요청하므로
  // index.html이 다시 로드되고 DOMContentLoaded 이벤트가 발생하여 render가 호출된다.
  window.addEventListener('DOMContentLoaded', render);

  (function () {
  const root = document.querySelector('.app-root');
  const navigation = document.getElementById('navigation');

  const routes = {
    // path: url
    '/': '/data/home.json',
    '/service': '/data/service.json',
    '/about': '/data/about.html'
  };

  const render = async path => {
    try {
      const url = routes[path];
      if (!url) {
        root.innerHTML = `${path} Not Found`;
        return;
      }

      const res = await fetch(url);
      const contentType = res.headers.get('content-type');

      if (contentType?.includes('application/json')) {
        const json = await res.json();
        root.innerHTML = `<h1>${json.title}</h1><p>${json.content}</p>`;
      } else {
        root.innerHTML = await res.text();
      }
    } catch (err) {
      console.error(err);
    }
  };

  // popstate 이벤트는 history entry가 변경되면 발생한다.
  // PJAX 방식은 hash를 사용하지 않으므로 hashchange 이벤트를 사용할 수 없다.
  // popstate 이벤트는 pushState에 의해 발생하지 않는다.
  // 이전페이지 / 다음페이지 button 또는 history.back() / history.go(n)에 의해 발생한다.
  window.addEventListener('popstate', e => {
    // e.state는 pushState 메서드의 첫번째 인수
    console.log('[popstate]', e.state);
    // 이전페이지 / 다음페이지 button이 클릭되면 render를 호출
    render(e.state.path);
  });

  // 네비게이션을 클릭하면 주소창의 url이 변경되므로 HTTP 요청이 서버로 전송된다.
  // preventDefault를 사용하여 이를 방지하고 history 관리를 위한 처리를 실시한다.
  navigation.addEventListener('click', e => {
    if (!e.target.matches('#navigation > li > a')) return;
    e.preventDefault();
    // 이동 페이지
    const path = e.target.getAttribute('href');

    // 주소창의 url은 변경되지만 HTTP 요청이 서버로 전송되지는 않는다.
    history.pushState({ path }, null, path);
    // path에 의한 AJAX 요청
    render(path);
  });

  // 웹페이지가 처음 로딩되었을 때
  render('/');

  // 새로고침이 클릭되었을 때, 현 페이지(예를 들어 loclahost:5004/service)가 서버에 요청된다.
  // 이에 응답하는 기능이 서버 측에 추가되어야 한다.
}());
}());
</script>
</body>
</html>
